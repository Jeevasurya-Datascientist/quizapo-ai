import { db } from './firebase';
import {
    collection,
    doc,
    runTransaction,
    query,
    where,
    getDocs,
    serverTimestamp,
    arrayUnion,
    increment,
    Timestamp
} from 'firebase/firestore';
import { FollowRequest, AppUser, SocialConnection } from '../types';

export const socialService = {

    // 1. Send Initial Follow Request
    async sendFollowRequest(fromUserId: string, toUserId: string) {
        // Deterministic ID to prevent duplicates
        const requestId = `${fromUserId}_${toUserId}`;
        const newReqRef = doc(db, 'follow_requests', requestId);

        // Check availability strictly
        const docSnap = await getDocs(query(collection(db, 'follow_requests'), where('fromUserId', '==', fromUserId), where('toUserId', '==', toUserId)));

        // If exact ID logic is preferred:
        // const docSnap = await getDoc(newReqRef); 
        // But query is safer if we ever messed up IDs before. 
        // Let's rely on the ID for the NEW write, but check query for existing loose ends? 
        // Actually, let's trust the ID for the new system.

        await runTransaction(db, async (transaction) => {
            const existingDoc = await transaction.get(newReqRef);
            if (existingDoc.exists()) {
                const status = existingDoc.data().status;
                if (['pending', 'pending_auto_followback', 'accepted'].includes(status)) {
                    throw new Error("Request already active");
                }
                // If rejected, we might allow re-requesting? For now, prevent spam.
                if (status === 'rejected') throw new Error("Request was rejected previously.");
            }

            // Allow re-creation or status reset if needed, but for now strict set.
            transaction.set(newReqRef, {
                id: requestId,
                fromUserId,
                toUserId,
                status: 'pending',
                createdAt: new Date().toISOString()
            });
        });

        return { id: requestId, fromUserId, toUserId, status: 'pending' };
    },

    // 2. Accept Request -> Trigger Auto-Follow-Back
    async acceptRequest(requestId: string, fromUserId: string, toUserId: string) {
        await runTransaction(db, async (transaction) => {
            const originalReqRef = doc(db, 'follow_requests', requestId);
            const originalDoc = await transaction.get(originalReqRef);

            if (!originalDoc.exists()) throw new Error("Request not found");
            const data = originalDoc.data();
            if (data.status !== 'pending') throw new Error(`Request not pending (Status: ${data.status})`);

            // Update original status
            transaction.update(originalReqRef, { status: 'accepted_by_receiver' });

            // Create Auto-Follow-Back Request (B -> A)
            // ID: receiver_originalSender
            const reverseReqId = `${toUserId}_${fromUserId}`;
            const reverseReqRef = doc(db, 'follow_requests', reverseReqId);

            const reverseReq: FollowRequest = {
                id: reverseReqId,
                fromUserId: toUserId, // B sends to A
                toUserId: fromUserId,
                status: 'pending_auto_followback',
                autoGenerated: true,
                createdAt: new Date().toISOString()
            };

            transaction.set(reverseReqRef, reverseReq);
        });
    },

    // 3. Reject Request
    async rejectRequest(requestId: string) {
        await runTransaction(db, async (transaction) => {
            const ref = doc(db, 'follow_requests', requestId);
            transaction.update(ref, { status: 'rejected' });
        });
    },

    // 4. Finalize Connection (User A accepts the auto-follow-back from B)
    async finalizeConnection(reverseRequestId: string, userAId: string, userBId: string) {
        await runTransaction(db, async (transaction) => {
            const revReqRef = doc(db, 'follow_requests', reverseRequestId);

            // Deterministic Connection ID
            const sortedIds = [userAId, userBId].sort();
            const connectionId = `${sortedIds[0]}_${sortedIds[1]}`;
            const connRef = doc(db, 'followers', connectionId);

            // READS FIRST
            const revDoc = await transaction.get(revReqRef);
            const connDoc = await transaction.get(connRef);

            // LOGIC CHECKS
            if (!revDoc.exists()) throw new Error("Request not found");
            if (revDoc.data().status !== 'pending_auto_followback') throw new Error("Invalid request state");

            // Idempotency check
            if (connDoc.exists()) return;

            // WRITES
            // 1. Update Request Status
            transaction.update(revReqRef, { status: 'accepted' });

            // 2. Create Mutual Connection
            const connection: SocialConnection = {
                id: connectionId,
                userA: userAId,
                userB: userBId,
                createdAt: new Date().toISOString()
            };
            transaction.set(connRef, connection);

            // 3. Update Counts & Arrays
            const userARef = doc(db, 'users', userAId);
            const userBRef = doc(db, 'users', userBId);

            transaction.update(userARef, {
                followersCount: increment(1),
                followingCount: increment(1),
                followers: arrayUnion(userBId),
                following: arrayUnion(userBId)
            });

            transaction.update(userBRef, {
                followersCount: increment(1),
                followingCount: increment(1),
                followers: arrayUnion(userAId),
                following: arrayUnion(userAId)
            });
        });
    }
};
